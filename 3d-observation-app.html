<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Object Observer - Spatial Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/23.1.1/tween.umd.js"></script>
    <style>
        :root {
            --bg: #FDFCF5; --panel: #FFFFFF; --text: #1e293b;
            --primary: #2563eb; --accent: #f59e0b; --border: #e2e8f0;
        }
        body { margin: 0; font-family: 'Inter', system-ui, sans-serif; background: var(--bg); color: var(--text); overflow-x: hidden; }
        .app-container { display: grid; grid-template-columns: 1fr 320px; height: 100vh; }
        
        /* 3D Stage */
        #stage-container { position: relative; flex-grow: 1; cursor: grab; }
        #stage-container:active { cursor: grabbing; }
        
        /* Controls Overlay */
        .controls { position: absolute; top: 20px; left: 20px; display: flex; flex-direction: column; gap: 10px; z-index: 10; }
        .btn-group { background: var(--panel); padding: 8px; border-radius: 12px; border: 1px solid var(--border); box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1); display: flex; gap: 5px; }
        button { padding: 8px 12px; border: 1px solid var(--border); background: white; border-radius: 6px; cursor: pointer; font-weight: 500; transition: all 0.2s; color: var(--text); }
        button:hover { background: #f8fafc; border-color: var(--primary); }
        button.active { background: var(--primary); color: white; border-color: var(--primary); }

        /* Projection Sidebar */
        .sidebar { background: var(--panel); border-left: 1px solid var(--border); padding: 20px; display: flex; flex-direction: column; gap: 20px; overflow-y: auto; }
        .projection-box { width: 100%; aspect-ratio: 1; border: 2px dashed var(--border); border-radius: 12px; position: relative; display: flex; align-items: center; justify-content: center; background: #fafafa; overflow: hidden; }
        .projection-box canvas { width: 100% !important; height: 100% !important; display: none; }
        .reveal-btn { z-index: 5; font-size: 0.85rem; padding: 10px 15px; }
        .label { font-size: 0.75rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; color: #64748b; margin-bottom: 5px; }
        
        .info-card { background: #eff6ff; border: 1px solid #dbeafe; padding: 15px; border-radius: 10px; font-size: 0.9rem; line-height: 1.5; }
        .discovery-text { font-style: italic; color: var(--primary); margin-top: 5px; font-size: 0.85rem; display: none; }

        @media (max-width: 768px) {
            .app-container { grid-template-columns: 1fr; }
            .sidebar { height: auto; border-left: none; border-top: 1px solid var(--border); }
        }
    </style>
</head>
<body>

<div class="app-container">
    <div id="stage-container">
        <div class="controls">
            <div class="btn-group">
                <select id="shapeSelect" onchange="updateObject()">
                    <option value="cube">Simple: Cube</option>
                    <option value="cylinder">Curved: Cylinder</option>
                    <option value="stairs">Complex: Stairs</option>
                    <option value="house">Compound: House</option>
                </select>
                <button onclick="toggleWireframe()" id="wireBtn">Wireframe Off</button>
            </div>
            <div class="btn-group">
                <button onclick="setView('free')" id="view-free" class="active">Free</button>
                <button onclick="setView('top')" id="view-top">Top</button>
                <button onclick="setView('front')" id="view-front">Front</button>
                <button onclick="setView('side')" id="view-side">Right</button>
            </div>
        </div>
    </div>

    <div class="sidebar">
        <h2 style="margin:0; font-size: 1.2rem;">Projections</h2>
        
        <div>
            <div class="label">Top View</div>
            <div class="projection-box" id="box-top">
                <button class="reveal-btn" onclick="reveal('top')">Click to Predict</button>
                <div class="discovery-text" id="desc-top"></div>
            </div>
        </div>

        <div>
            <div class="label">Front View</div>
            <div class="projection-box" id="box-front">
                <button class="reveal-btn" onclick="reveal('front')">Click to Predict</button>
                <div class="discovery-text" id="desc-front"></div>
            </div>
        </div>

        <div>
            <div class="label">Right Side View</div>
            <div class="projection-box" id="box-side">
                <button class="reveal-btn" onclick="reveal('side')">Click to Predict</button>
                <div class="discovery-text" id="desc-side"></div>
            </div>
        </div>

        <div class="info-card">
            <strong>Spatial Tip:</strong>
            <div id="spatial-tip">Select an object to begin.</div>
        </div>
    </div>
</div>

<script>
    let scene, camera, renderer, currentMesh, wireframe = false;
    let projScenes = { top: null, front: null, side: null };
    const shapes = {};
    const descriptions = {
        cube: { top: "A perfect square.", front: "A perfect square.", side: "A perfect square.", tip: "Cubes look identical from all primary angles." },
        cylinder: { top: "A circle from above.", front: "A rectangle! Depth is lost.", side: "Also a rectangle.", tip: "Curved surfaces flatten into rectangles in 2D." },
        stairs: { top: "Two rectangles side-by-side.", front: "The 'L' silhouette.", side: "A tall rectangle.", tip: "Steps appear as flat planes from above." },
        house: { top: "Two rectangles (roof) and a square (chimney).", front: "A pentagon shape with the chimney behind.", side: "A rectangle with a triangle on top.", tip: "Complex shapes are just combinations of simple ones." }
    };

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xFDFCF5);
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 5, 5);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('stage-container').appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 10, 7.5);
        scene.add(light, new THREE.AmbientLight(0xffffff, 0.5));
        scene.add(new THREE.GridHelper(10, 10, 0xcccccc, 0xeeeeee));

        setupProjections();
        updateObject();
        animate();
    }

    function setupProjections() {
        ['top', 'front', 'side'].forEach(view => {
            const container = document.getElementById(`box-${view}`);
            const pScene = new THREE.Scene();
            pScene.background = new THREE.Color(0xffffff);
            const pCam = new THREE.OrthographicCamera(-2, 2, 2, -2, 0.1, 10);
            
            if(view === 'top') pCam.position.set(0, 5, 0);
            if(view === 'front') pCam.position.set(0, 0, 5);
            if(view === 'side') pCam.position.set(5, 0, 0);
            pCam.lookAt(0,0,0);

            const pRen = new THREE.WebGLRenderer({ antialias: true });
            pRen.setSize(200, 200);
            container.appendChild(pRen.domElement);
            projScenes[view] = { scene: pScene, cam: pCam, ren: pRen };
        });
    }

    function updateObject() {
        if (currentMesh) scene.remove(currentMesh);
        const type = document.getElementById('shapeSelect').value;
        const material = new THREE.MeshPhongMaterial({ color: 0x2563eb, flatShading: true });
        
        let geo;
        if (type === 'cube') geo = new THREE.BoxGeometry(2, 2, 2);
        if (type === 'cylinder') geo = new THREE.CylinderGeometry(1, 1, 2, 32);
        if (type === 'stairs') {
            geo = new THREE.Shape();
            geo.moveTo(-1, -1); geo.lineTo(1, -1); geo.lineTo(1, 0); geo.lineTo(0, 0); geo.lineTo(0, 1); geo.lineTo(-1, 1);
            geo = new THREE.ExtrudeGeometry(geo, { depth: 2, bevelEnabled: false });
            geo.rotateY(Math.PI/2);
        }
        if (type === 'house') {
            const body = new THREE.BoxGeometry(2, 1.5, 2);
            const roof = new THREE.ConeGeometry(1.6, 1, 4);
            roof.rotateY(Math.PI/4); roof.translate(0, 1.25, 0);
            const chim = new THREE.BoxGeometry(0.4, 1, 0.4);
            chim.translate(0.5, 1.2, 0.5);
            geo = THREE.BufferGeometryUtils.mergeGeometries([body, roof, chim]);
        }

        currentMesh = new THREE.Mesh(geo, material);
        scene.add(currentMesh);
        
        // Reset Projections
        ['top', 'front', 'side'].forEach(v => {
            const p = projScenes[v];
            p.scene.clear();
            const pMesh = currentMesh.clone();
            p.scene.add(pMesh, new THREE.AmbientLight(0xffffff, 0.8), new THREE.DirectionalLight(0xffffff, 0.5));
            
            document.querySelector(`#box-${v} canvas`).style.display = 'none';
            document.querySelector(`#box-${v} .reveal-btn`).style.display = 'block';
            document.getElementById(`desc-${v}`).style.display = 'none';
        });

        document.getElementById('spatial-tip').innerText = descriptions[type].tip;
        applyWireframe();
    }

    function reveal(view) {
        document.querySelector(`#box-${view} canvas`).style.display = 'block';
        document.querySelector(`#box-${view} .reveal-btn`).style.display = 'none';
        const type = document.getElementById('shapeSelect').value;
        const desc = document.getElementById(`desc-${view}`);
        desc.innerText = descriptions[type][view];
        desc.style.display = 'block';
    }

    function setView(view) {
        document.querySelectorAll('.btn-group button').forEach(b => b.classList.remove('active'));
        document.getElementById(`view-${view}`).classList.add('active');
        
        let targetPos = { x: 5, y: 5, z: 5 };
        if(view === 'top') targetPos = { x: 0.01, y: 8, z: 0 };
        if(view === 'front') targetPos = { x: 0, y: 0, z: 8 };
        if(view === 'side') targetPos = { x: 8, y: 0, z: 0 };

        new TWEEN.Tween(camera.position).to(targetPos, 800).easing(TWEEN.Easing.Quadratic.Out).start();
    }

    function toggleWireframe() {
        wireframe = !wireframe;
        document.getElementById('wireBtn').innerText = wireframe ? "Solid Mode" : "Wireframe Mode";
        applyWireframe();
    }

    function applyWireframe() {
        currentMesh.material.wireframe = wireframe;
        ['top', 'front', 'side'].forEach(v => {
            projScenes[v].scene.children[0].material.wireframe = wireframe;
        });
    }

    function animate(time) {
        requestAnimationFrame(animate);
        TWEEN.update(time);
        renderer.render(scene, camera);
        Object.values(projScenes).forEach(p => p.ren.render(p.scene, p.cam));
    }

    // Basic Drag Rotation
    let isDragging = false, prevMouse = { x: 0, y: 0 };
    document.addEventListener('mousedown', () => isDragging = true);
    document.addEventListener('mouseup', () => isDragging = false);
    document.addEventListener('mousemove', (e) => {
        if(!isDragging || document.getElementById('view-free').className !== 'active') return;
        const deltaX = e.clientX - prevMouse.x;
        const deltaY = e.clientY - prevMouse.y;
        currentMesh.rotation.y += deltaX * 0.01;
        currentMesh.rotation.x += deltaY * 0.01;
        // Sync projections
        ['top', 'front', 'side'].forEach(v => {
            projScenes[v].scene.children[0].rotation.copy(currentMesh.rotation);
        });
        prevMouse = { x: e.clientX, y: e.clientY };
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
</script>
<!-- BufferGeometryUtils needed for House shape -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/utils/BufferGeometryUtils.js"></script>
<script>
    // Injection for BufferGeometryUtils in simple script tag environment
    THREE.BufferGeometryUtils = {
        mergeGeometries: (geos) => {
            const merged = new THREE.BufferGeometry();
            let pos = [], norm = [];
            geos.forEach(g => {
                const p = g.attributes.position.array;
                const n = g.attributes.normal.array;
                pos.push(...p); norm.push(...n);
            });
            merged.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            merged.setAttribute('normal', new THREE.Float32BufferAttribute(norm, 3));
            return merged;
        }
    };
</script>
</body>
</html>